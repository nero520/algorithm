package com.zmparty.math.algorithm;

/**
 * 不稳定
 * 空间复杂度O(1)
 * 希尔排序的时间性能优于直接插入排序的原因： 
 *  ①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。 
 *  ②当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。 
 *  ③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，
 *  而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。 
 *   因此，希尔排序在效率上较直接插人排序有较大的改进。
 *   增量序列的选择：Shell排序的执行时间依赖于增量序列。 
 *    好的增量序列的共同特征(查到的资料都这么讲)： 
 *     ① 最后一个增量必须为1； 
 *     ② 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。      
 * 属于插入类排序,由Shell提出，希尔排序对直接插入排序进行了简单的改进：
 * 它通过加大插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项大跨度地移动，
 * 当这些数据项排过一趟序之后，希尔排序算法减小数据项的间隔再进行排序，依次进行下去，
 * 进行这些排序时的数据项之间的间隔被称为增量，习惯上用字母h来表示这个增量。
 * 常用的h序列由Knuth提出，该序列从1开始，通过如下公式产生：
 * h = 3 * h +1
 * 反过来程序需要反向计算h序列，应该使用
 * h=(h-1)/3
 *
 */
public class ShellSort extends BaseSort {

	public static void main(String[] args) {
		int[] data = new int[]{ 5,2,7,6,1,3,8,9,4 };
		printRs(data);
		shellSort(data);
		printRs(data);
	}
	
	/**
	 * 基本思想：算法先将要排序的一组数按某个增量h分成若干组，
	 * 每组中记录的下标相差h.对每组中全部元素进行直接插入排序，然后再用一个较小的增量对它进行分组，
	 * 在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。
	 * @param data
	 */
	public static void shellSort(int[] data){
		
		//计算出最大h
		int h = 1;
		if(h<=data.length/3){
			h = 3*h+1;
		}
		
		int tmp = 0;
		while(h>0){
		for (int i = h; i < data.length; i+=h) {
			//缓存i处元素值
			tmp = data[i];
			int j = i-h;
			//前面的数整体后移h位
			while(j>=0&&tmp<data[j]){//曾经把1.K>=0写到了后面导致数组下标越界，2.曾经把tmp<data[k]写成了tmp>data[k]
				data[j+h] = data[j];
				j-=h;
			}
			//最后将tmp插入合适的位置
			data[j+h] = tmp;
			printRs(data,i,j+h,"====");
		}
		  //计算出下一个h值
		  h = (h - 1) / 3; 
		}
	}
	
	
}
